Shallow Copy vs. Deep Copy in JavaScript

When copying objects in JavaScript, it's essential to understand whether you're creating a shallow copy or a deep copy. These concepts determine how the copied object interacts with the original, especially when nested objects are involved.

// SHALLOW COPY
    A shallow copy creates a new object with copies of the original object's immediate properties. However, if the original object contains nested objects (objects within objects), the nested objects are shared between the original and the copy. This happens because only references to the nested objects are copied, not the actual nested objects themselves.

    How it Works
    Top-level properties are copied.
    Nested objects or arrays are not copied; they remain referenced.
   
    let original = {
      name: "John",
      details: { age: 30, city: "New York" },
    };

    let shallowCopy = { ...original }; // Spread operator for shallow copy

    shallowCopy.name = "Alice";
    shallowCopy.details.age = 35;

    console.log(original.name); // "John" (unchanged)
    console.log(original.details.age); // 35 (changed, shared reference)

    METHODS FOR SHALLOW COPY
 // Spread Operator (...)
    let copy = { ...original };

 //Object.assign()
    let copy = Object.assign({}, original);
//

// DEEP COPY
    A deep copy duplicates not only the top-level properties of the original object but also any nested objects or arrays. The copied object becomes entirely independent of the original, with no shared references.

    How it Works
    All levels of the object are fully cloned.
    Changes in the copy do not affect the original, and vice versa.
    
    
    let original = {
      name: "John",
      details: { age: 30, city: "New York" },
    };

    let deepCopy = structuredClone(original); // Deep copy method

    deepCopy.name = "Alice";
    deepCopy.details.age = 35;

    console.log(original.name); // "John" (unchanged)
    console.log(original.details.age); // 30 (unchanged)

    METHODS FOR DEEP COPY
    // structuredClone() (Modern Approach)
    Best for Deep Copy.
    Works for objects, arrays, and nested structures.
    let deepCopy = structuredClone(original);

    // JSON.parse(JSON.stringify(obj) (Older Approach)
    Caveats: Cannot handle functions, special objects like Date, Map, or Set.
    let deepCopy = JSON.parse(JSON.stringify(original));

    // Custom Recursive Function

    function deepClone(obj) {
      if (obj === null || typeof obj !== "object") return obj;
      let copy = Array.isArray(obj) ? [] : {};
      for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
          copy[key] = deepClone(obj[key]);
        }
      }
      return copy;
    }
    let deepCopy = deepClone(original);

    // Third-Party Libraries (e.g., Lodash)

    let _ = require("lodash");
    let deepCopy = _.cloneDeep(original);
// 

//
    COMPARISON TABLE
    Feature	                Shallow Copy	                        Deep Copy
    Top-level properties	Copies	                                Copies
    Nested objects/arrays	Shared references	                    Fully duplicated
    Mutual dependency	    Changes in nested objects affect both	Changes in nested objects are independent
    Performance	            Faster (less memory used)	            Slower (more memory used)
    Techniques	            Spread operator, Object.assign()	    structuredClone(), recursive functions

    USE CASES
    // When to Use Shallow Copy

    When dealing with flat objects (no nested objects or arrays).
    When modifications to nested objects are acceptable or intentional.
    let flatObject = { a: 1, b: 2 };
    let copy = { ...flatObject }; // Efficient for flat structures

    //When to Use Deep Copy

    When the object contains nested structures.
    When you need complete independence between the copy and the original.
    let complexObject = { a: { b: 2 } };
    let copy = structuredClone(complexObject); // Ensures no shared references

    // Key Takeaways
    A shallow copy is faster but maintains references to nested objects.
    A deep copy is independent but may be slower, depending on the size and complexity of the object.
    Use structuredClone() or libraries like Lodash for reliable deep copies.
//